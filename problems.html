<!DOCTYPE html>
<html>
<head>
<title>problems.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="dsa-problems">DSA Problems</h1>
<ul>
<li><a href="#arrays">Arrays</a>
<ul>
<li><a href="#1-two-sum">1. Two Sum</a></li>
<li><a href="#2-container-with-most-water">2. Container with most water</a></li>
<li><a href="#3-trapping-rain-water">3. Trapping Rain water</a></li>
<li><a href="#4--find-common-characters">4.  Find Common Characters</a></li>
</ul>
</li>
<li><a href="#strings">Strings</a>
<ul>
<li><a href="#1-typed-out-strings">1. Typed out strings</a></li>
<li><a href="#2-longest-substring-without-repeating-characters-medium">2. Longest Substring Without Repeating Characters (Medium)</a></li>
<li><a href="#3-palindromes">3. Palindromes</a></li>
<li><a href="#4-split-a-string-in-balanced-strings">4. Split a String in Balanced Strings</a></li>
</ul>
</li>
<li><a href="#linked-lists">Linked Lists</a>
<ul>
<li><a href="#1-reverse-a-linked-list">1. Reverse a Linked List</a></li>
<li><a href="#2-m-n-reversals">2. M, N Reversals</a></li>
<li><a href="#3-flatten-a-multilevel-doubly-linked-list">3. Flatten a Multilevel Doubly Linked List</a></li>
<li><a href="#4-cycle-detecting-in-linked-list">4. Cycle detecting in Linked List</a></li>
</ul>
</li>
<li><a href="#stacks">Stacks</a>
<ul>
<li><a href="#1-valid-parenthesis">1. Valid Parenthesis</a></li>
<li><a href="#2-minimum-remove-to-make-valid-parenthesis">2. Minimum Remove to Make Valid Parenthesis</a></li>
</ul>
</li>
<li><a href="#queues">Queues</a>
<ul>
<li><a href="#1-implement-queue-using-stacks">1. Implement Queue using Stacks</a></li>
</ul>
</li>
<li><a href="#recursionsorting-and-quickselect">Recursion(Sorting and Quickselect)</a>
<ul>
<li><a href="#1-factorial">1. Factorial</a></li>
<li><a href="#2-kth-largest-element-in-an-array">2. Kth Largest Element in an Array</a></li>
<li><a href="#3--binary-search">3.  Binary Search</a></li>
<li><a href="#4--find-first-and-last-position-of-element-in-sorted-array">4.  Find First and Last Position of Element in Sorted Array</a></li>
</ul>
</li>
<li><a href="#2d-arrays">2D Arrays</a>
<ul>
<li><a href="#1-2d-arraymatrix-traversal-using-dfs---recursive-approach">1. 2D Array(Matrix) traversal using DFS - Recursive Approach</a></li>
<li><a href="#2-2d-arraymatrix-traversal-using-bfs---recursive-approach">2. 2D Array(Matrix) traversal using BFS - Recursive Approach</a></li>
<li><a href="#3-number-of-islands">3. Number of Islands</a></li>
<li><a href="#4-rotten-oranges">4. Rotten Oranges</a></li>
<li><a href="#5-walls-and-gates">5. Walls and gates</a></li>
<li><a href="#6-search-a-2d-matrix">6. Search a 2D Matrix</a></li>
<li><a href="#7-set-matrix-zeroes">7. Set Matrix Zeroes</a></li>
<li><a href="#8-transpose-matrix">8. Transpose Matrix</a></li>
</ul>
</li>
<li><a href="#binary-trees">Binary trees</a>
<ul>
<li><a href="#1-maximum-depth-of-binary-tree">1. Maximum Depth of Binary Tree</a></li>
<li><a href="#2-binary-tree-level-order-traversal">2. Binary Tree Level Order Traversal</a></li>
<li><a href="#3-binary-tree-right-side-view">3. Binary Tree Right Side View</a></li>
<li><a href="#4-binary-tree-left-side-view">4. Binary Tree Left Side View</a></li>
<li><a href="#5--count-complete-tree-nodes">5.  Count Complete Tree Nodes</a></li>
<li><a href="#6-validate-binary-search-tree">6. Validate Binary Search Tree</a></li>
</ul>
</li>
</ul>
<h2 id="arrays">Arrays</h2>
<h3 id="1-two-sum">1. Two Sum</h3>
<p><a href="https://leetcode.com/problems/two-sum/">Q: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</a></p>
<p>Logic: find the target-currentElement in the array is present in array, if yes return the indices, if not traverse again.</p>
<p>Brute Force Solution: Two nested for loops,  compare first element with other elements in the array.. and so on .. till we find the target <a href="https://replit.com/@ZhangMYihua/two-sum-brute-force">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> numsArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> targetToFind = <span class="hljs-number">11</span>;


<span class="hljs-keyword">const</span> findTwoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>; p1 &lt; nums.length; p1++) {
    
    <span class="hljs-keyword">const</span> numberToFind = target - nums[p1];

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p2 = p1 + <span class="hljs-number">1</span>; p2 &lt; nums.length; p2++) {
      <span class="hljs-keyword">if</span>(numberToFind === nums[p2]) {
        <span class="hljs-keyword">return</span> [p1, p2];
      }
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

<span class="hljs-built_in">console</span>.log(findTwoSum(numsArray, targetToFind));
</div></code></pre>
<p>Optimal Solution: Using hashmap, store the target-currentitem in hashmap, if it found return the value  <a href="https://replit.com/@ZhangMYihua/two-sum-optimal-solution">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> numsArray = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> targetToFind = <span class="hljs-number">11</span>;

<span class="hljs-keyword">const</span> findTwoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>{
  <span class="hljs-keyword">const</span> numsMap = {};
  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>; p &lt; nums.length; p++) {
    <span class="hljs-keyword">const</span> currentMapVal = numsMap[nums[p]];

    <span class="hljs-keyword">if</span>(currentMapVal &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> [currentMapVal, p];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> numberToFind = target - nums[p];
      numsMap[numberToFind] = p;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">console</span>.log(findTwoSum(numsArray, targetToFind));
</div></code></pre>
<h3 id="2-container-with-most-water">2. Container with most water</h3>
<p><a href="https://leetcode.com/problems/container-with-most-water/">Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</a></p>
<p>Logic: find water between two points by calculating <code>water = Math.min(arr[i], arr[j]) * j-1</code> and then Maxwater= Math.max(maxwater, water) gives the max water container</p>
<p>Brute Force solution: Nested for loops <a href="https://replit.com/@ZhangMYihua/maximum-water-container-brute-force-solution">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> heightsArray = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>];

<span class="hljs-keyword">const</span> getMaxWaterContainer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>{
  <span class="hljs-keyword">let</span> maxArea = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>; p1 &lt; heights.length; p1++) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p2 = p1 + <span class="hljs-number">1</span>; p2 &lt; heights.length; p2++) {
      <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">Math</span>.min(heights[p1], heights[p2]);
      <span class="hljs-keyword">const</span> width = p2 - p1;
      <span class="hljs-keyword">const</span> area = height * width;
      maxArea = <span class="hljs-built_in">Math</span>.max(maxArea, area);
    }
  };

  <span class="hljs-keyword">return</span> maxArea;
}

<span class="hljs-built_in">console</span>.log(getMaxWaterContainer(heightsArray));
</div></code></pre>
<p>Optimal solution:  two pointer solution, let p1 be the first item , p2 be the last item and traverse the elements using while loop. <a href="https://replit.com/@ZhangMYihua/maximum-water-container-optimal-solution">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> heightsArray = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>];

<span class="hljs-keyword">const</span> getMaxWaterContainer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>{
  <span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>, p2 = heights.length - <span class="hljs-number">1</span>, maxArea = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span>(p1 &lt; p2) {
    <span class="hljs-keyword">const</span> height = <span class="hljs-built_in">Math</span>.min(heights[p1], heights[p2]);
    <span class="hljs-keyword">const</span> width = p2 - p1;
    <span class="hljs-keyword">const</span> area = height * width;
    maxArea = <span class="hljs-built_in">Math</span>.max(maxArea, area);
    
    <span class="hljs-keyword">if</span>(heights[p1] &lt;= heights[p2]) {
      p1++;
    } <span class="hljs-keyword">else</span> {
      p2--;
    }
  }

  <span class="hljs-keyword">return</span> maxArea;
}

<span class="hljs-built_in">console</span>.log(getMaxWaterContainer(heightsArray));
</div></code></pre>
<h3 id="3-trapping-rain-water">3. Trapping Rain water</h3>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</a></p>
<p>Logic: We need to find the water at a give point of element. let c be the current item.  maximum element of left side of c is maxLeft, and maximum element of right side of c is maxRight. and then water unit at that element can be calculated as <code>Math.min(maxLeft, maxRight) - arr[c]</code> where arr[c] is the current element height.</p>
<p>Brute force solution:  for loop is used to traverse all elements and while is used for find the maxRight and maxLeft <a href="https://replit.com/@ZhangMYihua/trapping-rainwater-brute-force-solution#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> heights = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMax</span>(<span class="hljs-params">heights</span>)</span>{
 <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;   

 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;heights.length; i++){
  <span class="hljs-keyword">let</span> maxL = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxR = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = i+<span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> left = i<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">while</span>(right &lt; heights.length){
      maxR = <span class="hljs-built_in">Math</span>.max(maxR, heights[right]);
      right++;   
  }
  <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span>){
      maxL = <span class="hljs-built_in">Math</span>.max(maxL, heights[left]);
      left--;
  }
  <span class="hljs-keyword">let</span> waterunit = <span class="hljs-built_in">Math</span>.min(maxL, maxR) - heights[i];
  total += waterunit &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span>: waterunit;
 }

 <span class="hljs-keyword">return</span> total;
}

getMax(heights);
</div></code></pre>
<p>Optimal solution:using while loop and two pointers solution <a href="https://replit.com/@ZhangMYihua/trapping-rainwater-optimal-solution">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> getTrappedRainwater = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) </span>{

  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = heights.length - <span class="hljs-number">1</span>, totalWater = <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;
  
  <span class="hljs-keyword">while</span>(left &lt; right) {
    <span class="hljs-keyword">if</span>(heights[left] &lt;= heights[right]) {
      <span class="hljs-keyword">if</span>(heights[left] &gt;= maxLeft) { 
        maxLeft = heights[left]
      } <span class="hljs-keyword">else</span> { 
        totalWater += maxLeft - heights[left];
      }
      left++;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span>(heights[right] &gt;= maxRight) {
          maxRight = heights[right];
      } <span class="hljs-keyword">else</span> {
          totalWater += maxRight - heights[right];
      }
        
      right--;
    }
  }

  <span class="hljs-keyword">return</span> totalWater;
}
</div></code></pre>
<h3 id="4-find-common-characters">4.  Find Common Characters</h3>
<p><a href="https://leetcode.com/problems/find-common-characters/">Given an array words of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order.</a></p>
<pre class="hljs"><code><div>Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]
Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]] 
</div></code></pre>
<p>Logic: From the given Array(A), we take the first item as the reference and add it to our result. then iterate all the items in the A.slice(1) and filter the result array by checking if char present in result is also present in the current item, then replace that char with empty string,and return    <code>return len &gt; A[i] </code> where len is the length of A[i] before performing operations.</p>
<p>Solution: <a href="https://leetcode.com/submissions/detail/503044741/">Leetcode</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> commonChars = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">words</span>) </span>{
    <span class="hljs-keyword">let</span> result = [...words[<span class="hljs-number">0</span>]];
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;words.length; i++){
        result = result.filter(<span class="hljs-function"><span class="hljs-params">char</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> len = words[i].length;
            words[i] = words[i].replace(char, <span class="hljs-string">""</span>);
            <span class="hljs-keyword">return</span> len&gt;words[i].length;
        });
    }
    
    <span class="hljs-keyword">return</span> result;
};
</div></code></pre>
<hr>
<h2 id="strings">Strings</h2>
<h3 id="1-typed-out-strings">1. Typed out strings</h3>
<p><a href="https://leetcode.com/problems/backspace-string-compare/">Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
</a></p>
<p>Logic: Using stacks. Traverse through the chars in the given string, if the current is not equal to &quot;#&quot; push it to the stack, and if it equals pop out the last element in the stack.</p>
<p>Brute force solution: <a href="https://replit.com/@ZhangMYihua/typed-out-strings-brute-force#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> backspaceCompare = <span class="hljs-function">(<span class="hljs-params">S, T</span>) =&gt;</span> convert(S) === convert(T);

<span class="hljs-keyword">const</span> convert = <span class="hljs-function"><span class="hljs-params">String</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> temp = [];
    <span class="hljs-keyword">for</span>(c <span class="hljs-keyword">of</span> <span class="hljs-built_in">String</span>){
        c !== <span class="hljs-string">"#"</span> ?  temp.push(c) : temp.pop();
    }
    <span class="hljs-keyword">return</span> temp.join(<span class="hljs-string">""</span>);
}
</div></code></pre>
<p>Optimal solution: Two pointer solution, initially p1 is pointing to lastelement in the firstArray, p2 is pointing to lastelement in the secondArray.. if p1 === p2 then increment the counters.<a href="https://replit.com/@ZhangMYihua/backspace-string-compare-optimal">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> string1 = <span class="hljs-string">"ab#z"</span>
<span class="hljs-keyword">const</span> string2 = <span class="hljs-string">"az#z"</span>

<span class="hljs-keyword">var</span> backspaceCompare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">S, T</span>) </span>{
    <span class="hljs-keyword">let</span> p1 = S.length - <span class="hljs-number">1</span>, p2 = T.length - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span>(S[p1] === <span class="hljs-string">"#"</span> || T[p2] === <span class="hljs-string">"#"</span>) {
            <span class="hljs-keyword">if</span>(S[p1] === <span class="hljs-string">"#"</span>) {
                <span class="hljs-keyword">let</span> backCount = <span class="hljs-number">2</span>;
                
                <span class="hljs-keyword">while</span>(backCount &gt; <span class="hljs-number">0</span>) {
                    p1--;
                    backCount--;
                    
                    <span class="hljs-keyword">if</span>(S[p1] === <span class="hljs-string">"#"</span>) {
                        backCount += <span class="hljs-number">2</span>;
                    }
                }
            }
            
            <span class="hljs-keyword">if</span>(T[p2] === <span class="hljs-string">"#"</span>) {
                <span class="hljs-keyword">let</span> backCount = <span class="hljs-number">2</span>;
                
                <span class="hljs-keyword">while</span>(backCount &gt; <span class="hljs-number">0</span>) {
                    p2--;
                    backCount--;
                    
                    <span class="hljs-keyword">if</span>(T[p2] === <span class="hljs-string">"#"</span>) {
                        backCount += <span class="hljs-number">2</span>;
                    }
                }
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span>(S[p1] !== T[p2]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            } <span class="hljs-keyword">else</span> {
                p1--;
                p2--;
            }
        }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-built_in">console</span>.log(backspaceCompare(string1, string2));
</div></code></pre>
<h3 id="2-longest-substring-without-repeating-characters-medium">2. Longest Substring Without Repeating Characters (Medium)</h3>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Given a string s, find the length of the longest substring without repeating characters.</a></p>
<p>Logic: store the chars one by one in temp variable, and longest  = temp.length, if it encounters repeating char, then slice the string.</p>
<p>Solution 1: Using temp variable</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> {
 <span class="hljs-keyword">const</span> strLen = str.length;
 <span class="hljs-keyword">if</span>(strLen &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> strLen;
 <span class="hljs-keyword">let</span> longest = <span class="hljs-number">0</span>, temp = <span class="hljs-string">""</span>;
 <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; strLen; i++){
   <span class="hljs-keyword">if</span>(temp.indexOf(str[i]) &gt;= <span class="hljs-number">0</span>){
      temp = temp.slice(temp.indexOf(str[i])+<span class="hljs-number">1</span>) + str[i];
   }
   <span class="hljs-keyword">else</span>{
       temp = temp + str[i];
       longest = <span class="hljs-built_in">Math</span>.max(longest, temp.length);
   } 
 }
 <span class="hljs-keyword">return</span> longest
}
</div></code></pre>
<p>Solution 2: Using hashmap <a href="https://replit.com/@ZhangMYihua/longest-substring-without-repeat-characters-optimal">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> string = <span class="hljs-string">"au"</span>

<span class="hljs-keyword">const</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">if</span>(s.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.length;
    
    <span class="hljs-keyword">const</span> seen = {};
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, longest = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
        <span class="hljs-keyword">const</span> currentChar = s[right];
        <span class="hljs-keyword">const</span> previouslySeenChar = seen[currentChar];
        
        <span class="hljs-keyword">if</span>(previouslySeenChar &gt;= left) {
          left = previouslySeenChar + <span class="hljs-number">1</span>;
        }
        
        seen[currentChar] = right;
        
        longest = <span class="hljs-built_in">Math</span>.max(longest, right - left + <span class="hljs-number">1</span>);
    }
    
    <span class="hljs-keyword">return</span> longest;
};

<span class="hljs-built_in">console</span>.log(lengthOfLongestSubstring(string));

</div></code></pre>
<h3 id="3-palindromes">3. Palindromes</h3>
<p>Approaches: Following are some of approaches to find if a string is palindrome or not.</p>
<ol>
<li>Approach: Two pointers technique.let p be the first char in the given string and q be the last char in the given string. and compare p === q if true then do p++ and q-- ... if it is false then return not a palindrome. Inward pointers, in this case pointers move inwards</li>
<li>Approach: Instead of inward pointer, in this case pointers are at center position and they move outward</li>
<li>Approach: Given string is S. In this apporach we reverse the given string and store it in variable S'.  let p pointer is pointing to first char in the S and q pointer is pointing to first char in S'. then compare p and q.</li>
<li>Approach: Using builtin methods. reverse the string and compare <code>str === str.reverse()</code></li>
</ol>
<p><a href="https://leetcode.com/problems/valid-palindrome/">Q1: Valid Palindromes - 1</a></p>
<p>Solutions:</p>
<ul>
<li><a href="https://replit.com/@ZhangMYihua/Valid-Palindrome-2-pointers-from-center#main.js">outward pointers</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Valid-Palindrome-2-pointers-from-outside">inward pointers</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Valid-Palindrome-compare-against-reverse#main.js">string reverse</a></li>
</ul>
<p><a href="https://leetcode.com/problems/valid-palindrome-ii/">Q2: Valid Palindrome - 11</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/Almost-palindrome-solution#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> validPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> p=<span class="hljs-number">0</span>,
        q=s.length<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span>(p &lt;= q){
        <span class="hljs-keyword">if</span>(s[p] !== s[q]){
            <span class="hljs-keyword">return</span> isValid(s,p+<span class="hljs-number">1</span>, q) || isValid(s, p, q<span class="hljs-number">-1</span>);
        }
        p++;
        q--;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">s, p, q</span>)</span>{
  <span class="hljs-keyword">while</span>(p &lt; q){
      <span class="hljs-keyword">if</span>(s[p] !== s[q]){
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
      };
      p++;
      q--;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}

validPalindrome(abca);
</div></code></pre>
<h3 id="4-split-a-string-in-balanced-strings">4. Split a String in Balanced Strings</h3>
<p><a href="https://leetcode.com/problems/split-a-string-in-balanced-strings/">Balanced strings are those that have an equal quantity of 'L' and 'R' characters.Given a balanced string s, split it in the maximum amount of balanced strings.Return the maximum amount of split balanced strings.</a></p>
<p>Logic: Using stack, we will push the first char in the given string to the stack, then  we will push again if we the see the same character else pop out the last element. then check stack length if it zero push it to our results array.</p>
<p>Solution: <a href="https://leetcode.com/submissions/detail/502989590/">Leetcode</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> balancedStringSplit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> stack = [];
    stack.push(s[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;s.length; i++){
        <span class="hljs-keyword">if</span>(stack.includes(s[i]) || stack.length === <span class="hljs-number">0</span>){
            stack.push(s[i]);
        }
        <span class="hljs-keyword">else</span>{
            stack.pop();
            <span class="hljs-keyword">if</span>(!stack.length){
                result += <span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> result;
};
</div></code></pre>
<hr>
<h2 id="linked-lists">Linked Lists</h2>
<h3 id="1-reverse-a-linked-list">1. Reverse a Linked List</h3>
<p><a href="https://leetcode.com/problems/reverse-linked-list/">Given the head of a singly linked list, reverse the list, and return the reversed list.</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/reverse-linked-list#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> head = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: {
          <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>,
          <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
        }
      }
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseLL</span>(<span class="hljs-params">head</span>)</span>{
  <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> cn = head;
  <span class="hljs-keyword">while</span>(cn){
    <span class="hljs-keyword">let</span> next = cn.next;
    cn.next = prev;
    prev = cn;
    cn = next;
  }
  <span class="hljs-keyword">while</span>(prev){
    <span class="hljs-built_in">console</span>.log(prev.value);
    prev = prev.next;
  }
}

<span class="hljs-built_in">console</span>.log(reverseLL(head));

</div></code></pre>
<h3 id="2-m-n-reversals">2. M, N Reversals</h3>
<p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/M-N-reversals">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-function">(<span class="hljs-params">head, left, right</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> start = head, cn = head, currentPos = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(currentPos &lt; left){
        start = cn;
        cn = cn.next;
        currentPos++;
    }
    <span class="hljs-keyword">let</span> tail = cn, newList = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">while</span>(currentPos &gt;= left &amp;&amp; currentPos &lt;= right){
        next = cn.next;
        cn.next = newList;
        newList = cn;
        cn = next;
        currentPos++;
    }
    start.next = newList;
    tail.next = cn;
    <span class="hljs-keyword">if</span>(left &gt; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> head;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> newList;
    }
    
}
</div></code></pre>
<h3 id="3-flatten-a-multilevel-doubly-linked-list">3. Flatten a Multilevel Doubly Linked List</h3>
<p><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/">You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/merge-multi-level-doubly-linked-list#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> flatten = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>{
    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;
    <span class="hljs-keyword">let</span> cn = head, start = head, tail = <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">while</span>(cn){
        <span class="hljs-keyword">if</span>(cn.child){
            start = cn;
            <span class="hljs-keyword">let</span> temp = cn.child;
            <span class="hljs-keyword">while</span>(temp){
                tail = temp;
                temp = temp.next;
            }
            <span class="hljs-keyword">if</span>(tail){
                next = start.next;
                start.next = start.child;
                tail.next = next;
                <span class="hljs-keyword">if</span>(next) next.prev = tail;
                start.child.prev = start;
                start.child = <span class="hljs-literal">null</span>;  
            }
        }
        cn = cn.next;
    }
    <span class="hljs-keyword">return</span> head;
};
</div></code></pre>
<h3 id="4-cycle-detecting-in-linked-list">4. Cycle detecting in Linked List</h3>
<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">Given a linked list, return the node where the cycle begins. If there is no cycle, return null.There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.Notice that you should not modify the linked list.</a></p>
<p>Brute force solution: Using set, add the each node to the set, if the element is present in set then return element. <a href="https://replit.com/@ZhangMYihua/cycle-detection-with-Set">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>{
    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;
    <span class="hljs-keyword">let</span> cn = head, <span class="hljs-keyword">set</span> = new Set();
    while(cn){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">set</span>.has(cn)){
            <span class="hljs-keyword">return</span> cn;
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">set</span>.add(cn);
        }
        cn = cn.next;
    }
    return null;
};
</div></code></pre>
<p>Optimal solution: Using tortoise and hare(rabbit) alogirthm, the idea here is to increase the tortoise pointer by 1 and hare pointer by 2; if hair reaches the last value and it is null, then no cycle is detected.if hare and tortoise meets(equal), then cycle is detected. from there let p1 be the head and p2 be the last meeting point of hare and tortoise, if both p1===p2 return p1 or p2;<a href="https://replit.com/@ZhangMYihua/cycle-detection-Flyods-tortoise-and-hare#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>{
        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> tortoise = head, hare = head;
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
            tortoise = tortoise.next;
            hare = hare.next;
            <span class="hljs-keyword">if</span>(hare === <span class="hljs-literal">null</span> || hare.next === <span class="hljs-literal">null</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">else</span>{
                hare = hare.next;
            }
            <span class="hljs-keyword">if</span>(tortoise === hare) <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">let</span> p1 = head, p2 = hare;
        <span class="hljs-keyword">while</span>(p1 !== p2){
            p1 = p1.next;
            p2 = p2.next;
        }
        <span class="hljs-keyword">return</span> p1;
};
</div></code></pre>
<hr>
<h2 id="stacks">Stacks</h2>
<h3 id="1-valid-parenthesis">1. Valid Parenthesis</h3>
<p><a href="https://leetcode.com/problems/valid-parentheses/">Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.</a></p>
<p>Solution: Using stacks and hashmaps. Hashmap is used to mapping pairs and when we encounter open element we push that to the stack, and when we see close we pop the stack <code>map[stack.pop()] !== c</code> return false. else if the stack length is empty true. <a href="https://replit.com/@ZhangMYihua/valid-parentheses#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> isValid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">var</span> map = {
        <span class="hljs-string">"("</span> : <span class="hljs-string">")"</span>,
        <span class="hljs-string">"["</span> : <span class="hljs-string">"]"</span>,
        <span class="hljs-string">"{"</span> : <span class="hljs-string">"}"</span>,
    };

    <span class="hljs-keyword">let</span> stack = [];
    <span class="hljs-keyword">for</span>(c <span class="hljs-keyword">of</span> s){
        <span class="hljs-keyword">if</span>(c === <span class="hljs-string">"("</span> || c === <span class="hljs-string">"{"</span> || c === <span class="hljs-string">"["</span>){
            stack.push(c);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">if</span>(map[stack.pop()] !== c){
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;
};
</div></code></pre>
<h3 id="2-minimum-remove-to-make-valid-parenthesis">2. Minimum Remove to Make Valid Parenthesis</h3>
<p><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.</a></p>
<p>Solution:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> minRemoveToMakeValid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">let</span> res = s.split(<span class="hljs-string">""</span>),
        stack = [];
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;res.length; i++){
        <span class="hljs-keyword">if</span>(res[i] === <span class="hljs-string">"("</span>){
            stack.push(i);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[i] === <span class="hljs-string">")"</span> &amp;&amp; stack.length){
            stack.pop();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[i] === <span class="hljs-string">")"</span>){
            res[i] = <span class="hljs-string">""</span>;
        }
    }
    
    <span class="hljs-keyword">while</span>(stack.length){
        <span class="hljs-keyword">const</span> ci = stack.pop();
        res[ci] = <span class="hljs-string">""</span>;
    }
    
    <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">""</span>);
};
</div></code></pre>
<hr>
<h2 id="queues">Queues</h2>
<h3 id="1-implement-queue-using-stacks">1. Implement Queue using Stacks</h3>
<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/">Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/Create-Queue-using-stacks">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> MyQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.stackIn = [];
    <span class="hljs-keyword">this</span>.stackOut = [];
};

MyQueue.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">this</span>.stackIn.push(x);
};

MyQueue.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.stackOut);
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.stackOut.length === <span class="hljs-number">0</span>){
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.stackIn.length){
            <span class="hljs-keyword">this</span>.stackOut.push(<span class="hljs-keyword">this</span>.stackIn.pop());
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackOut.pop();
};

MyQueue.prototype.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.stackOut.length === <span class="hljs-number">0</span>){
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.stackIn.length){
            <span class="hljs-keyword">this</span>.stackOut.push(<span class="hljs-keyword">this</span>.stackIn.pop());
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackOut[<span class="hljs-keyword">this</span>.stackOut.length<span class="hljs-number">-1</span>];
};

MyQueue.prototype.empty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.stackIn.length === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.stackOut.length === <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<hr>
<h2 id="recursionsorting-and-quickselect">Recursion(Sorting and Quickselect)</h2>
<h3 id="1-factorial">1. Factorial</h3>
<p><strong>Normal Recursion</strong></p>
<p>Solution: Space complexity O(n), as call stack needs to remember previous value in every step. Here original function call is waiting for the subsequent recursive calls. so it has to store all the function calls in the stack.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>)</span>{
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> n * factorial(n<span class="hljs-number">-1</span>);

}

factorial(<span class="hljs-number">5</span>);
</div></code></pre>
<p><strong>TailRecursion</strong></p>
<p>Solution: Space complexity is O(1), we return the value of function call every time, we dont need to store the previous value. Here original function dont need to store anything, when original call is executed it passes the value by performing some calculations to the next recursive calls. so we dont store anything here.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n, total=<span class="hljs-number">1</span></span>)</span>{
    <span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> total;
    }
    <span class="hljs-keyword">return</span> factorial(n<span class="hljs-number">-1</span>, total * n);

}

factorial(<span class="hljs-number">5</span>);
</div></code></pre>
<h3 id="2-kth-largest-element-in-an-array">2. Kth Largest Element in an Array</h3>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Given an integer array nums and an integer k, return the kth largest element in the array.Note that it is the kth largest element in the sorted order, not the kth distinct element.</a></p>
<p>Solution 1: Using built in methods:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>{
    <span class="hljs-keyword">if</span>(nums.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums;
    <span class="hljs-keyword">return</span> nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a-b)[nums.length-k];
};
</div></code></pre>
<p>Solution 2:  Using quicksort <a href="https://replit.com/@ZhangMYihua/Find-kth-largest-element-Quicksort#main.js">Repl</a></p>
<p>Solution 3: Using quickselect<a href="https://replit.com/@ZhangMYihua/Find-kth-largest-element-Quickselect#main.js">Repl</a></p>
<h3 id="3-binary-search">3.  Binary Search</h3>
<p><a href="https://leetcode.com/problems/binary-search/">Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.</a></p>
<p>Solution:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.length<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span>(left &lt;= right){
        <span class="hljs-keyword">let</span> middle = <span class="hljs-built_in">Math</span>.floor((left+right)/<span class="hljs-number">2</span>);
        <span class="hljs-keyword">const</span> foundVal = nums[middle];
        <span class="hljs-keyword">if</span>(foundVal === target){
           <span class="hljs-keyword">return</span> middle;
        }
        <span class="hljs-keyword">if</span>(foundVal &lt; target){
            left = middle+<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            right = middle<span class="hljs-number">-1</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
};
</div></code></pre>
<h3 id="4-find-first-and-last-position-of-element-in-sorted-array">4.  Find First and Last Position of Element in Sorted Array</h3>
<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].You must write an algorithm with O(log n) runtime complexity.</a></p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/Find-start-and-end-of-target-OlogN#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> searchRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N, T</span>) </span>{
    <span class="hljs-keyword">const</span> find = <span class="hljs-function">(<span class="hljs-params">target, arr, left=<span class="hljs-number">0</span>, right=arr.length</span>) =&gt;</span> {
        <span class="hljs-keyword">while</span> (left &lt;= right) {
            <span class="hljs-keyword">let</span> mid = left + right &gt;&gt; <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> (arr[mid] &lt; target) left = mid + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>
        }
        <span class="hljs-keyword">return</span> left
    } 
    <span class="hljs-keyword">let</span> Tleft = find(T, N)
    <span class="hljs-keyword">if</span> (N[Tleft] !== T) <span class="hljs-keyword">return</span> [<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">return</span> [Tleft, find(T+<span class="hljs-number">1</span>, N, Tleft) - <span class="hljs-number">1</span>]
};
</div></code></pre>
<hr>
<h2 id="2d-arrays">2D Arrays</h2>
<h3 id="1-2d-arraymatrix-traversal-using-dfs---recursive-approach">1. 2D Array(Matrix) traversal using DFS - Recursive Approach</h3>
<pre class="hljs"><code><div>input:
const testMatrix = [
  [1,    2,     3,    4,    5],
  [6,    7,     8,    9,   10],
  [11,  12,  13,  14,  15],
  [16,  17,  18,  19,  20]
];
output: 
[
  1,  2,  3,  4,  5, 10, 15,  20, 19, 14, 9,  8, 13, 18, 17, 12,  7, 6, 11, 16
]
</div></code></pre>
<p>Solution: <a href="https://replit.com/@kantesrikanth/2DArraysDFS#index.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> input = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
  [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>],
  [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>],
  [<span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>]
];

<span class="hljs-keyword">const</span> traversalDFS = <span class="hljs-function">(<span class="hljs-params">matrix</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> seen = <span class="hljs-built_in">Array</span>(matrix.length).fill(<span class="hljs-number">0</span>)
              .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(matrix[<span class="hljs-number">0</span>].length).fill(<span class="hljs-literal">false</span>));
  
  <span class="hljs-keyword">let</span> output = [];

  helper(matrix, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, seen, output);

  <span class="hljs-keyword">return</span> output;
}

<span class="hljs-keyword">const</span> helper = <span class="hljs-function">(<span class="hljs-params">matrix, row, col, seen, output</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= matrix.length || col &gt;= matrix[<span class="hljs-number">0</span>].length || seen[row][col]) <span class="hljs-keyword">return</span>;
  output.push(matrix[row][col]);
  seen[row][col] = <span class="hljs-literal">true</span>;

  helper(matrix, row<span class="hljs-number">-1</span>, col, seen, output);
  helper(matrix, row, col+<span class="hljs-number">1</span>, seen, output);
  helper(matrix, row+<span class="hljs-number">1</span>, col, seen, output);
  helper(matrix, row, col<span class="hljs-number">-1</span>, seen, output);
}



traversalDFS(input);
</div></code></pre>
<h3 id="2-2d-arraymatrix-traversal-using-bfs---recursive-approach">2. 2D Array(Matrix) traversal using BFS - Recursive Approach</h3>
<pre class="hljs"><code><div>input:
const testMatrix = [
  [1,    2,     3,    4,    5],
  [6,    7,     8,    9,   10],
  [11,  12,  13,  14,  15],
  [16,  17,  18,  19,  20]
];
output: 
[
   1,  2,  5,  3, 6,  9,  4,  7, 10, 13, 8, 11, 14, 12, 15, 16
]
</div></code></pre>
<p>Solution: <a href="https://replit.com/@kantesrikanth/2DArrayBFSTraversal">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> input = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
  [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],
  [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>],
  [<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>]
];

<span class="hljs-keyword">const</span> traversalBFS = <span class="hljs-function">(<span class="hljs-params">matrix</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> seen = <span class="hljs-built_in">Array</span>(matrix.length).fill(<span class="hljs-number">0</span>)
                .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(matrix[<span class="hljs-number">0</span>].length).fill(<span class="hljs-literal">false</span>));
  <span class="hljs-keyword">const</span> output = [];
  <span class="hljs-keyword">const</span> queue = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]];
  <span class="hljs-keyword">while</span>(queue.length){
    <span class="hljs-keyword">const</span> [row, col] = queue.shift();
    <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= matrix.length || col &gt;= matrix[<span class="hljs-number">0</span>].length || seen[row][col]) <span class="hljs-keyword">continue</span>;
    output.push(matrix[row][col]);
    seen[row][col] = <span class="hljs-literal">true</span>;

    queue.push([row<span class="hljs-number">-1</span>, col]);
    queue.push([row, col+<span class="hljs-number">1</span>]);
    queue.push([row+<span class="hljs-number">1</span>, col]);
    queue.push([row, col<span class="hljs-number">-1</span>]);
  }
  <span class="hljs-keyword">return</span> output;
}

traversalBFS(input);
</div></code></pre>
<h3 id="3-number-of-islands">3. Number of Islands</h3>
<p><a href="https://leetcode.com/problems/number-of-islands/">Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</a></p>
<p>Logic: Using nested for loops, and if <code>grid[row][col] === &quot;1&quot;,</code> then increment do <code>countIslands++</code> and then we need to convert all the 1's that are connected into 0's. This is to ensure that we don't count duplicate islands. to do this we need to perform either BFS/DFS. and after for loop execution is done return the <code>countIslands</code>;</p>
<p>Initially we are performing sequential traverse by using nested for loops, and then using BFS/DFS to traverse the adjacent top/down/left/right values.</p>
<p>Approach using Sequential + DFS:</p>
<p>Solution:
- <a href="https://leetcode.com/submissions/detail/503097503/">Leetcode</a>
- <a href="https://replit.com/@ZhangMYihua/Number-of-Islands-DFS#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> numIslands = <span class="hljs-function">(<span class="hljs-params">grid</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> row=<span class="hljs-number">0</span>; row&lt;grid.length; row++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> col=<span class="hljs-number">0</span>; col&lt;grid[<span class="hljs-number">0</span>].length; col++){
            <span class="hljs-keyword">if</span>(grid[row][col] === <span class="hljs-string">"1"</span>){
                count++;
                traverse(grid, row, col);
            }
        }
    }
    <span class="hljs-keyword">return</span> count;
};

<span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">grid, row, col</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= grid.length || col &gt;= grid[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(grid[row][col] === <span class="hljs-string">"1"</span>){
        grid[row][col] = <span class="hljs-string">"0"</span>;    
        traverse(grid, row<span class="hljs-number">-1</span>, col);
        traverse(grid, row, col+<span class="hljs-number">1</span>);
        traverse(grid, row+<span class="hljs-number">1</span>, col);
        traverse(grid, row, col<span class="hljs-number">-1</span>);
    }
}
</div></code></pre>
<p>Approach using Sequential + BFS:</p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/Number-of-Islands-BFS#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> input = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
];

<span class="hljs-keyword">const</span> directions = [
  [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">//up</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-comment">//right</span>
  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">//down</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>] <span class="hljs-comment">//left</span>
]

<span class="hljs-keyword">const</span> numberOfIslands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>{
  <span class="hljs-keyword">if</span>(matrix.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> islandCount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; matrix.length; row++) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; matrix[<span class="hljs-number">0</span>].length; col++) {
      <span class="hljs-keyword">if</span>(matrix[row][col] === <span class="hljs-number">1</span>) {
        islandCount++;
        matrix[row][col] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> queue = [];
        queue.push([row, col]);

        <span class="hljs-keyword">while</span>(queue.length) {
          <span class="hljs-keyword">const</span> currentPos = queue.shift();
          <span class="hljs-keyword">const</span> currentRow = currentPos[<span class="hljs-number">0</span>];
          <span class="hljs-keyword">const</span> currentCol = currentPos[<span class="hljs-number">1</span>];

          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; directions.length; i++) {
            <span class="hljs-keyword">const</span> currentDir = directions[i];
            <span class="hljs-keyword">const</span> nextRow = currentRow + currentDir[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">const</span> nextCol = currentCol + currentDir[<span class="hljs-number">1</span>];

            <span class="hljs-keyword">if</span>(nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= matrix.length || nextCol &lt; <span class="hljs-number">0</span> || nextCol &gt;= matrix[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">continue</span>;

            <span class="hljs-keyword">if</span>(matrix[nextRow][nextCol] === <span class="hljs-number">1</span>) {
              queue.push([nextRow, nextCol]);
              matrix[nextRow][nextCol] = <span class="hljs-number">0</span>;
            }
          }
        }
      }
    }
  }

  <span class="hljs-keyword">return</span> islandCount;
}

<span class="hljs-built_in">console</span>.log(numberOfIslands(input));
</div></code></pre>
<h3 id="4-rotten-oranges">4. Rotten Oranges</h3>
<p><a href="https://leetcode.com/problems/rotting-oranges/">You are given an m x n grid where each cell can have one of three values:0 representing an empty cell,1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</a></p>
<p>Logic: First we need to push the rotten oranges [row, col]into new queue and store total no of fresh orange in a variable by using sequential traversal(nested for loops). then after that  we need to run BFS on the queue, then decrease the fresh orange count when we see it. and also we need to keep track of minutes variable, if single BFS is completed then minutes++. finally if the freshOrange &gt; 0 then we need to return -1, else return minutes.</p>
<p>Solution: <a href="https://replit.com/@ZhangMYihua/Rotting-Oranges-Solution#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> testMatrix = [
  [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
];

<span class="hljs-keyword">const</span> directions = [
  [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">//up</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-comment">//right</span>
  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], <span class="hljs-comment">//down</span>
  [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>] <span class="hljs-comment">//left</span>
]

<span class="hljs-keyword">const</span> ROTTEN = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> FRESH = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> EMPTY = <span class="hljs-number">0</span>;


<span class="hljs-keyword">const</span> orangesRotting = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>{
  <span class="hljs-keyword">if</span>(matrix.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> queue = [];  
  <span class="hljs-keyword">let</span> freshOranges = <span class="hljs-number">0</span>;
  
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; matrix.length; row++) {
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; matrix[<span class="hljs-number">0</span>].length; col++) {
      <span class="hljs-keyword">if</span>(matrix[row][col] === ROTTEN) {
        queue.push([row, col])
      }
      
      <span class="hljs-keyword">if</span>(matrix[row][col] === FRESH) {
        freshOranges++;
      }
    }
  }
    
  <span class="hljs-keyword">let</span> minutes = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> currentQueueSize = queue.length;
  
  <span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(currentQueueSize === <span class="hljs-number">0</span>) {
      currentQueueSize = queue.length;
      minutes++;
    }

    <span class="hljs-keyword">const</span> currentOrange = queue.shift();
    currentQueueSize--;
    <span class="hljs-keyword">const</span> row = currentOrange[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> col = currentOrange[<span class="hljs-number">1</span>];
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; directions.length; i++) {
      <span class="hljs-keyword">const</span> currentDir = directions[i];
      <span class="hljs-keyword">const</span> nextRow = row + currentDir[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">const</span> nextCol = col + currentDir[<span class="hljs-number">1</span>];
      
      <span class="hljs-keyword">if</span>(nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= matrix.length || nextCol &lt; <span class="hljs-number">0</span> || nextCol &gt;= matrix[<span class="hljs-number">0</span>].length) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (matrix[nextRow][nextCol] === FRESH) {
        matrix[nextRow][nextCol] = <span class="hljs-number">2</span>;
        freshOranges--;
        queue.push([nextRow, nextCol]);
      }
    }
  }
  
  <span class="hljs-keyword">if</span>(freshOranges !== <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }
  
  <span class="hljs-keyword">return</span> minutes;
};

<span class="hljs-built_in">console</span>.log(orangesRotting(testMatrix)
</div></code></pre>
<h3 id="5-walls-and-gates">5. Walls and gates</h3>
<p>Q: Suppose we have one m x n 2D grid, and that is initialized with these three possible values.-1 for a wall or an obstacle.0 for a gate.INF This is infinity means an empty room.Here 2^31 - 1 = 2147483647 is INF as we may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.
<a href="https://www.geeksforgeeks.org/find-shortest-distance-guard-bank/">GFG</a>
<a href="https://leetcode.com/problems/walls-and-gates/">Leetcode</a></p>
<p>Logic: The idea is to perform sequential search and perform BFS/DFS. In the sequential search if current element is equal to GATE(0), then we need to perfrom the BFS/DFS and replace the current[row][col] = count; if count &gt; current[row][col] we skip. if not perform BFS/DFS.</p>
<p>Solution:</p>
<ul>
<li><a href="https://replit.com/@kantesrikanth/2DArrayWallsgate#index.js">Repl</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Walls-and-Gates-Solution#main.js">Repl</a></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> input = [
  [<span class="hljs-literal">Infinity</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">Infinity</span>],
  [<span class="hljs-literal">Infinity</span>, <span class="hljs-literal">Infinity</span>, <span class="hljs-literal">Infinity</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-literal">Infinity</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">Infinity</span>, <span class="hljs-number">-1</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">Infinity</span>, <span class="hljs-literal">Infinity</span>]
];

<span class="hljs-keyword">const</span> wallsAndGates = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> {
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> row=<span class="hljs-number">0</span>; row&lt;arr.length; row++){
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> col=<span class="hljs-number">0</span>; col&lt;arr[<span class="hljs-number">0</span>].length; col++){
      <span class="hljs-keyword">if</span>(arr[row][col] === <span class="hljs-number">0</span>){
        dfs(arr, row, col, <span class="hljs-number">0</span>);
      }
    }
  }
  <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">arr, row, col, count</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span> ||  row&gt;=arr.length  || col&lt;<span class="hljs-number">0</span> || col&gt;=arr[<span class="hljs-number">0</span>].length || count &gt; arr[row][col]) <span class="hljs-keyword">return</span>;
     arr[row][col] = count;
     dfs(arr, row<span class="hljs-number">-1</span>, col, count+<span class="hljs-number">1</span>);
     dfs(arr, row, col+<span class="hljs-number">1</span>, count+<span class="hljs-number">1</span>);
     dfs(arr, row+<span class="hljs-number">1</span>, col, count+<span class="hljs-number">1</span>);
     dfs(arr, row, col<span class="hljs-number">-1</span>, count+<span class="hljs-number">1</span>);
}

wallsAndGates(input);

output: 
[ [ <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ], [ <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span> ], [ <span class="hljs-number">0</span>,<span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ] ]

</div></code></pre>
<h3 id="6-search-a-2d-matrix">6. Search a 2D Matrix</h3>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix/">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row.</a></p>
<h3 id="7-set-matrix-zeroes">7. Set Matrix Zeroes</h3>
<p><a href="https://leetcode.com/problems/set-matrix-zeroes/">Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place.</a></p>
<h3 id="8-transpose-matrix">8. Transpose Matrix</h3>
<p><a href="https://leetcode.com/problems/transpose-matrix/">Given a 2D integer array matrix, return the transpose of matrix.The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.</a></p>
<hr>
<h2 id="binary-trees">Binary trees</h2>
<h3 id="1-maximum-depth-of-binary-tree">1. Maximum Depth of Binary Tree</h3>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Given the root of a binary tree, return its maximum depth.A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node</a></p>
<p>Approach:  Using recursion, we traverse through all the elements until it is null, and return the max count of lefttraversal and righttraversal.</p>
<p>Solution:</p>
<ul>
<li><a href="https://replit.com/@ZhangMYihua/Maximum-depth#main.js">Repl</a></li>
<li><a href="https://leetcode.com/submissions/detail/499406238/">Leetcode</a></li>
<li><a href="https://leetcode.com/submissions/detail/503281533/">Leetcode</a></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">return</span> traverse(root, <span class="hljs-number">0</span>);
};
<span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">node, count</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> count;
    count++;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(traverse(node.left, count), traverse(node.right, count));
}
</div></code></pre>
<p><strong>or</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">height</span>(<span class="hljs-params">node</span>)</span>{
     <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
     <span class="hljs-keyword">var</span> lh = height(node.left);
     <span class="hljs-keyword">var</span> rh = height(node.right);
     <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(lh, rh)+<span class="hljs-number">1</span>; 
  }
  <span class="hljs-keyword">return</span> height(root);
};
</div></code></pre>
<h3 id="2-binary-tree-level-order-traversal">2. Binary Tree Level Order Traversal</h3>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</a></p>
<p>Solution:</p>
<ul>
<li><a href="https://leetcode.com/submissions/detail/503291226/">Leetcode</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Level-Order">Repl</a></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> levelOrder = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">const</span> result = [], queue = [root];
    <span class="hljs-keyword">while</span>(queue.length){
        <span class="hljs-keyword">let</span> count  = <span class="hljs-number">0</span>, length = queue.length, currentLevelArrays = [];
        <span class="hljs-keyword">while</span>(count &lt; length){
            <span class="hljs-keyword">const</span> currentNode = queue.shift();
            currentLevelArrays.push(currentNode.val);
            <span class="hljs-keyword">if</span>(currentNode.left) queue.push(currentNode.left);
            <span class="hljs-keyword">if</span>(currentNode.right) queue.push(currentNode.right);
            count++;
        }
        result.push(currentLevelArrays);        
    }
    <span class="hljs-keyword">return</span> result;
};
</div></code></pre>
<h3 id="3-binary-tree-right-side-view">3. Binary Tree Right Side View</h3>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/">Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</a></p>
<p>Approach: Using BFS and we need to check for if the currentNode is right most element or not, if yes push it to the output array else do nothing. To check if the element in the level is right most or not, we need to keep track of node level using <code>Count</code> property as shown in the below.</p>
<p>Solution:</p>
<ul>
<li><a href="https://leetcode.com/submissions/detail/503306990/">Leetcode</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Binary-tree-right-side-view-BFS#main.js">Repl</a></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> rightSideView = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">let</span> output= [], queue = [root];
    <span class="hljs-keyword">while</span>(queue.length){
        <span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>, length = queue.length;
        <span class="hljs-keyword">while</span>(count &lt; length){
            <span class="hljs-keyword">const</span> currentNode  = queue.shift();
            <span class="hljs-keyword">if</span>(currentNode.left) queue.push(currentNode.left);
            <span class="hljs-keyword">if</span>(currentNode.right) queue.push(currentNode.right);
            count++;
            <span class="hljs-keyword">if</span>(count === length){
                output.push(currentNode.val);
            }
        }
    }
    <span class="hljs-keyword">return</span> output;
};
</div></code></pre>
<p>Approach: Using DFS <a href="https://replit.com/@ZhangMYihua/Binary-tree-right-side-view-DFS#main.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">node, currentLevel, result</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span>(currentLevel &gt;= result.length) {
    result.push(node.value);
  }

  <span class="hljs-keyword">if</span>(node.right) {
    dfs(node.right, currentLevel + <span class="hljs-number">1</span>, result);
  }
  
  <span class="hljs-keyword">if</span>(node.left) {
    dfs(node.left, currentLevel + <span class="hljs-number">1</span>, result);
  }
}

<span class="hljs-keyword">const</span> rightSideViewDFS = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  
  dfs(root, <span class="hljs-number">0</span>, result);
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-built_in">console</span>.log(rightSideViewDFS(tree))
</div></code></pre>
<h3 id="4-binary-tree-left-side-view">4. Binary Tree Left Side View</h3>
<p><a href="https://www.geeksforgeeks.org/print-left-view-binary-tree/">Given a Binary Tree, print left view of it. Left view of a Binary Tree is set of nodes visible when tree is visited from left side.</a></p>
<p>Approach:  Using BFS and we need to check for if the currentNode is left most element or not, if yes push it to the output array else do nothing. To check if the element in the level is left most or not, we need to keep track of node level using <code>Count</code> property as shown in the below. if <code>count===1</code> that means it is the first element in the left view.</p>
<p>Solution: <a href="https://replit.com/@kantesrikanth/BinaryTreeLeftView#index.js">Repl</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> leftSideView = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];
    <span class="hljs-keyword">let</span> output= [], queue = [root];
    <span class="hljs-keyword">while</span>(queue.length){
        <span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>, length = queue.length;
        <span class="hljs-keyword">while</span>(count &lt; length){
            <span class="hljs-keyword">const</span> currentNode  = queue.shift();
            <span class="hljs-keyword">if</span>(currentNode.left) queue.push(currentNode.left);
            <span class="hljs-keyword">if</span>(currentNode.right) queue.push(currentNode.right);
            count++;
            <span class="hljs-keyword">if</span>(count === <span class="hljs-number">1</span>){
                output.push(currentNode.val);
            }
        }
    }
    <span class="hljs-keyword">return</span> output;
};
</div></code></pre>
<h3 id="5-count-complete-tree-nodes">5.  Count Complete Tree Nodes</h3>
<p><a href="https://leetcode.com/problems/count-complete-tree-nodes/">Given the root of a complete binary tree, return the number of the nodes in the tree.According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.Design an algorithm that runs in less than O(n) time complexity.</a></p>
<p>Brute Force: Traversing each node in the tree and keep track of count. <a href="https://leetcode.com/submissions/detail/503333512/">Leetcode</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> countNodes = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>Optimal solution: Find the left most depth and right most depth, if equal return <code>Math.pow(s, leftLen)-1</code>; <a href="https://leetcode.com/submissions/detail/503333762/">Leetcode</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> countNodes = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> leftDepth = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> leftDepth(node.left)+<span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">const</span> rightDepth = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> rightDepth(node.right)+<span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">const</span> traverse = <span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> leftLen = leftDepth(node);
        <span class="hljs-keyword">const</span> rightLen = rightDepth(node);
        <span class="hljs-keyword">if</span>(leftLen === rightLen) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, leftLen)<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> traverse(node.left) + traverse(node.right) + <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">return</span> traverse(root);
};
</div></code></pre>
<h3 id="6-validate-binary-search-tree">6. Validate Binary Search Tree</h3>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">Given the root of a binary tree, determine if it is a valid binary search tree (BST).</a></p>
<p>Apporach: Check if each element is within the range of Min, Max if yes true, then again perfrom the same check for node.left and node.right element, if yes return true, else false;</p>
<p>Solution:</p>
<ul>
<li><a href="https://leetcode.com/submissions/detail/503340525/">Leetcode</a></li>
<li><a href="https://replit.com/@ZhangMYihua/Validate-Binary-Search-Tree#main.js">Repl</a></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>{
    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> isBst = <span class="hljs-function">(<span class="hljs-params">node, min, max</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span>(node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(node.val &gt; min &amp;&amp; node.val &lt; max &amp;&amp; isBst(node.left, min, node.val) &amp;&amp; isBst(node.right, node.val, max)){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> isBst(root, <span class="hljs-built_in">Math</span>.max(), <span class="hljs-built_in">Math</span>.min());
};

</div></code></pre>
<hr>

</body>
</html>
